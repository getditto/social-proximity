/*! \file */
/*******************************************
 *                                         *
 *  File auto-generated by `::safer_ffi`.  *
 *                                         *
 *  Do not manually edit this file.        *
 *                                         *
 *******************************************/

#ifndef __RUST_DITTOFFI__
#define __RUST_DITTOFFI__
#ifdef __cplusplus
extern "C" {
#endif
typedef enum LicenseVerificationResult {
    /** . */
    LICENSE_VERIFICATION_RESULT_LICENSE_OK = 0,
    /** . */
    LICENSE_VERIFICATION_RESULT_VERIFICATION_FAILED = -1,
    /** . */
    LICENSE_VERIFICATION_RESULT_LICENSE_EXPIRED = -2,
    /** . */
    LICENSE_VERIFICATION_RESULT_UNSUPPORTED_FUTURE_VERSION = -3,
} LicenseVerificationResult_t;

/** \brief
 *  Verify a base64 encoded license string
 * 
 *  # Parameters
 *  - `license`: A base64 encoded license string. This should be the output of
 *    `dittolicenser::license_mgr::generate()`.
 *  - `out_error_msg`: An optional error message out parameter which will be written
 *     to if the license verification. This error message is simplified and appropriate
 *     to show directly to an SDK user.
 */
LicenseVerificationResult_t verify_license (
    char const * license,
    char * * out_err_msg);

typedef struct UninitializedDitto UninitializedDitto_t;

/** \brief
 *  Make an UninitializedDitto object as an opaque pointer.
 * 
 *  This object serves as an intermediate object that allows database access.
 *  This allows the SDK to check if a pre-existing site ID has been persisted.
 */
UninitializedDitto_t * uninitialized_ditto_make (
    char const * working_dir);


#include <stddef.h>
#include <stdint.h>

/** \brief
 *  Check the store for an existing cached site ID.
 * 
 *  Returns 0 if no existing site ID could be fetched.
 */
uint32_t uninitialized_ditto_get_site_id (
    UninitializedDitto_t const * uninit_ditto);

typedef struct Ditto Ditto_t;

/** \brief
 *  Make a Ditto object as an opaque pointer, using the built-in development ID
 *  for testing.
 * 
 *  The Ditto object creates the Tokio runtime and starts internal threads. The
 *  return value is a raw pointer whose only use is to supply as an argument to
 *  other `ditto_*` functions. The Ditto object must be stopped and freed with
 *  `ditto_free()`.
 */
Ditto_t * ditto_make_development (
    UninitializedDitto_t * uninit_ditto,
    uint32_t site_id,
    char const * app_name);

/** \brief
 *  Make a Ditto object as an opaque pointer, using shared key authentication.
 *  This is the same as `ditto_make_development` except that authentication is
 *  by a shared key, passed as base64-encoded DER.
 */
Ditto_t * ditto_make_shared_key (
    UninitializedDitto_t * uninit_ditto,
    uint32_t site_id,
    char const * app_name,
    char const * key_der_b64);

/** \brief
 *  Make a Ditto object as an opaque pointer. The Ditto object creates the Tokio
 *  runtime and starts internal threads. The return value is a raw pointer whose
 *  only use is to supply as an argument to other ditto_* functions. The Ditto
 *  object must be stopped and freed with ditto_free().
 */
Ditto_t * ditto_make_production (
    UninitializedDitto_t * uninit_ditto,
    char const * certificate_config_str);

/** \brief
 *  Stop replication and all internal threads in the Ditto object.
 *  The ditto object is freed by this function and must not be used again.
 */
void ditto_free (
    Ditto_t * ditto);

void ditto_remove_mdns_advertiser (
    Ditto_t const * ditto);

/** \brief
 *  Clear the callbacks used for diagnostics.
 */
void ditto_clear_status_callbacks (
    Ditto_t * ditto);

/** \brief
 *  Clear the store of an existing cached site ID, if one exists.
 */
int32_t ditto_clear_site_id (
    Ditto_t * ditto);

void ditto_remove_subscription (
    Ditto_t const * ditto,
    char const * collection,
    char const * query);

/** \brief
 *  Add a subscription
 */
void ditto_add_subscription (
    Ditto_t const * ditto,
    char const * collection,
    char const * query);

typedef struct TransportHandle_StaticTcpClientPlatformEvent TransportHandle_StaticTcpClientPlatformEvent_t;

TransportHandle_StaticTcpClientPlatformEvent_t * ditto_add_static_tcp_client (
    Ditto_t const * ditto,
    char const * address);

typedef struct TransportHandle_WebsocketClientPlatformEvent TransportHandle_WebsocketClientPlatformEvent_t;

TransportHandle_WebsocketClientPlatformEvent_t * ditto_add_websocket_client (
    Ditto_t const * ditto,
    char const * address);

/** \brief
 *  Start the WebSocket server
 */
int32_t ditto_start_tcp_server (
    Ditto_t const * ditto,
    char const * bind);

/** \brief
 *  Whether or not to offer a WebSocket sync server on the HTTP server.
 */
typedef enum WebSocketMode {
    /** . */
    WEB_SOCKET_MODE_ENABLED,
    /** . */
    WEB_SOCKET_MODE_DISABLED,
} WebSocketMode_t;

/** \brief
 *  Start the WebSocket server
 * 
 *  * `bind` - optional bind string of the form "ip:port"
 *  * `static_path` - optional absolute path to content on disk that should be served from `/`
 *  * `enable_websocket` - whether to enable a WebSocket server at the reserved path `/_ditto/ws`
 *  * `tls_cert_path` - path to this server's TLS certificate file, or null if not using TLS
 *  * `tls_key_path` - path to this server's TLS private key file, or null if not using TLS
 */
int32_t ditto_start_http_server (
    Ditto_t const * ditto,
    char const * bind,
    char const * static_path,
    WebSocketMode_t enable_websocket,
    char const * tls_cert_path,
    char const * tls_key_path);

int32_t ditto_stop_tcp_server (
    Ditto_t const * ditto);

void ditto_invalidate_tcp_listeners (
    Ditto_t const * ditto);

/** \brief
 *  Listen address of `tcp_listen_transport`.
 * 
 *  Must be called after `transport_go_online()`.
 *  The return value must be freed with `ditto_c_string_free()`.
 */
char * ditto_tcp_server_listen_addr (
    Ditto_t * ditto);

/** \brief
 *  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.
 * 
 *  # C layout (for some given type T)
 * 
 *  ```c
 *  typedef struct {
 *      // Cannot be NULL
 *      T * ptr;
 *      size_t len;
 *  } slice_T;
 *  ```
 * 
 *  # Nullable pointer?
 * 
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct {

    /** \brief
     *  Pointer to the first element (if any).
     */
    uint8_t const * ptr;

    /** \brief
     *  Element count
     */
    size_t len;

} slice_ref_uint8_t;

typedef struct {

    void (*start_searching)(void *, char const *);

    void (*stop_searching)(void *);

    void (*resolve_service)(void *, slice_ref_uint8_t);

} MdnsClientCallbacks_t;

typedef struct TransportHandle_MdnsClientPlatformEvent TransportHandle_MdnsClientPlatformEvent_t;

TransportHandle_MdnsClientPlatformEvent_t * ditto_add_mdns_transport (
    Ditto_t * ditto,
    MdnsClientCallbacks_t callbacks,
    void * ctx,
    void (*retain)(void *),
    void (*release)(void *));

typedef struct {

    void (*start_advertising)(void *, char const *, char const *, uint16_t);

    void (*stop_advertising)(void *);

} MdnsServerCallbacks_t;

typedef struct TransportHandle_MdnsServerPlatformEvent TransportHandle_MdnsServerPlatformEvent_t;

TransportHandle_MdnsServerPlatformEvent_t * ditto_add_mdns_advertiser (
    Ditto_t * ditto,
    MdnsServerCallbacks_t callbacks,
    void * ctx,
    void (*retain)(void *),
    void (*release)(void *));

/** \brief
 *  Request bulk status information about the transports. Intended mostly for
 *  statistical or debugging purposes.
 */
char * ditto_transports_diagnostics (
    Ditto_t * ditto);

/** \brief
 *  Request data showing who we are connected to in a user-friendly way.
 */
char * ditto_presence_v1 (
    Ditto_t * ditto);

/** \brief
 *  User-friendly categories describing where condition events arose
 */
typedef enum ConditionSource {
    /** . */
    CONDITION_SOURCE_BLUETOOTH,
    /** . */
    CONDITION_SOURCE_TCP,
    /** . */
    CONDITION_SOURCE_AWDL,
    /** . */
    CONDITION_SOURCE_MDNS,
} ConditionSource_t;

/** \brief
 *  A code reported by platforms/transports to indicate specific health
 *  conditions
 */
typedef enum TransportCondition {
    /** \brief
     *  A default state. Only use this for transient conditions, e.g., we are
     *  waiting for a platform to finish starting up. If everything is just
     *  quiet, use `Ok`.
     */
    TRANSPORT_CONDITION_UNKNOWN,
    /** \brief
     *  No known problems.
     */
    TRANSPORT_CONDITION_OK,
    /** \brief
     *  Catch-all failure, particularly for unexpected/internal faults. If
     *  possible, add a new case that the customer will be able to
     *  interpret.
     */
    TRANSPORT_CONDITION_GENERIC_FAILURE,
    /** \brief
     *  App is in background.
     */
    TRANSPORT_CONDITION_APP_IN_BACKGROUND,
    /** \brief
     *  We are not able to publish or discover with the mDNS daemon.
     */
    TRANSPORT_CONDITION_MDNS_FAILURE,
    /** \brief
     *  We cannot bind to a port.
     */
    TRANSPORT_CONDITION_TCP_LISTEN_FAILURE,
    /** \brief
     *  No app permission to act as a BLE Central.
     */
    TRANSPORT_CONDITION_NO_BLE_CENTRAL_PERMISSION,
    /** \brief
     *  No app permission to act as a BLE Peripheral.
     */
    TRANSPORT_CONDITION_NO_BLE_PERIPHERAL_PERMISSION,
    /** \brief
     *  This Transport targets a particular peer and we can't reach them right
     *  now.
     */
    TRANSPORT_CONDITION_CANNOT_ESTABLISH_CONNECTION,
    /** \brief
     *  The device has Bluetooth disabled at the OS level.
     */
    TRANSPORT_CONDITION_BLE_DISABLED,
    /** \brief
     *  The device has no Bluetooth hardware.
     */
    TRANSPORT_CONDITION_NO_BLE_HARDWARE,
    /** \brief
     *  The device has Wifi disabled at the OS level.
     */
    TRANSPORT_CONDITION_WIFI_DISABLED,
    /** \brief
     *  The platform has suspended briefly for internal reasons. Peers are
     *  reset.
     */
    TRANSPORT_CONDITION_TEMPORARILY_UNAVAILABLE,
} TransportCondition_t;

/** \brief
 *  Register a function that will be called every time a transport changes
 *  condition.
 * 
 *  This should drive UI indicators to indicate overall connectivity via methods
 *  such as BLE, WiFi, or an internet-based server on a dedicated
 *  WsConnectTransport.
 */
void ditto_register_transport_condition_changed_callback (
    Ditto_t * ditto,
    void * ctx,
    void (*retain)(void *),
    void (*release)(void *),
    void (*c_cb)(void *, ConditionSource_t, TransportCondition_t));

/** \brief
 *  Register a function that will be called every time the connection state
 *  of remote peers changes.
 */
void ditto_register_presence_v1_callback (
    Ditto_t * ditto,
    void * ctx,
    void (*retain)(void *),
    void (*release)(void *),
    void (*c_cb)(void *, char const *));

typedef struct {
    uint8_t idx[16];
} uint8_16_array_t;

/** \brief
 *  Generic enum used by crate and platforms to indicate online-ness.
 * 
 *  In other words, is something active or not? Not everything will use the
 *  transitional states.
 */
typedef enum OnlineState {
    /** . */
    ONLINE_STATE_OFFLINE,
    /** . */
    ONLINE_STATE_ONLINE,
    /** . */
    ONLINE_STATE_GOING_ONLINE,
    /** . */
    ONLINE_STATE_GOING_OFFLINE,
} OnlineState_t;


#include <stdbool.h>

/** \brief
 *  Rust-level representation of the result of a send operation, converted from
 *  a bitfield
 */
typedef struct {

    bool accepted;

    bool wait_for_ready;

} SendResult_t;

/** \brief
 *  When receiving data from a Bluetooth LE peer, such as a characteristic
 *  write, indicates what sort of data it is.
 */
typedef enum BleDataType {
    /** \brief
     *  The data _should_ contain the remote peer's announce string.
     *  Used during handshake.
     */
    BLE_DATA_TYPE_ANNOUNCE = 0,
    /** \brief
     *  Data message
     */
    BLE_DATA_TYPE_MESH_DATA = 1,
    /** \brief
     *  Control message
     */
    BLE_DATA_TYPE_CONTROL = 2,
} BleDataType_t;

typedef struct {

    void (*start_scanning)(void *, uint8_16_array_t const *, slice_ref_uint8_t);

    void (*stop_scanning)(void *);

    OnlineState_t (*scanning_state)(void *);

    void (*connect_peripheral)(void *, uint8_16_array_t const *);

    void (*disconnect_peripheral)(void *, uint8_16_array_t const *);

    SendResult_t (*write_to_peripheral)(void *, BleDataType_t, uint8_16_array_t const *, slice_ref_uint8_t);

    bool (*app_is_in_foreground)(void *);

} BleClientCallbacks_t;

typedef struct TransportHandle_BleClientPlatformEvent TransportHandle_BleClientPlatformEvent_t;

TransportHandle_BleClientPlatformEvent_t * ditto_add_ble_client_transport (
    Ditto_t * ditto,
    BleClientCallbacks_t callbacks,
    void * ctx,
    void (*retain)(void *),
    void (*release)(void *));

typedef struct {

    void (*start_advertising)(void *, uint8_16_array_t const *, slice_ref_uint8_t);

    void (*stop_advertising)(void *);

    OnlineState_t (*advertising_state)(void *);

    SendResult_t (*notify_to_central)(void *, BleDataType_t, uint8_16_array_t const *, slice_ref_uint8_t);

    bool (*app_is_in_foreground)(void *);

} BleServerCallbacks_t;

typedef struct TransportHandle_BleServerPlatformEvent TransportHandle_BleServerPlatformEvent_t;

TransportHandle_BleServerPlatformEvent_t * ditto_add_ble_server_transport (
    Ditto_t * ditto,
    BleServerCallbacks_t callbacks,
    void * ctx,
    void (*retain)(void *),
    void (*release)(void *));

/** \brief
 *  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.
 * 
 *  # C layout (for some given type T)
 * 
 *  ```c
 *  typedef struct {
 *      // Cannot be NULL
 *      T * ptr;
 *      size_t len;
 *  } slice_T;
 *  ```
 * 
 *  # Nullable pointer?
 * 
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct {

    /** \brief
     *  Pointer to the first element (if any).
     */
    uint8_t * ptr;

    /** \brief
     *  Element count
     */
    size_t len;

} slice_mut_uint8_t;

typedef struct {

    void (*start_searching)(void *, char const *, char const *);

    void (*stop_searching)(void *);

    void (*request_connect)(void *, char const *);

    void (*request_disconnect)(void *, char const *);

    int32_t (*send_data)(void *, char const *, slice_ref_uint8_t);

    int32_t (*read_data)(void *, char const *, slice_mut_uint8_t);

} AwdlClientCallbacks_t;

typedef struct TransportHandle_AwdlClientPlatformEvent TransportHandle_AwdlClientPlatformEvent_t;

TransportHandle_AwdlClientPlatformEvent_t * ditto_add_awdl_client_transport (
    Ditto_t * ditto,
    AwdlClientCallbacks_t callbacks,
    void * ctx,
    void (*retain)(void *),
    void (*release)(void *));

typedef struct {

    void (*start_advertising)(void *, char const *, char const *);

    void (*stop_advertising)(void *);

    void (*request_disconnect)(void *, int64_t);

    int32_t (*send_data)(void *, int64_t, slice_ref_uint8_t);

    int32_t (*read_data)(void *, int64_t, slice_mut_uint8_t);

} AwdlServerCallbacks_t;

typedef struct TransportHandle_AwdlServerPlatformEvent TransportHandle_AwdlServerPlatformEvent_t;

TransportHandle_AwdlServerPlatformEvent_t * ditto_add_awdl_server_transport (
    Ditto_t * ditto,
    AwdlServerCallbacks_t callbacks,
    void * ctx,
    void (*retain)(void *),
    void (*release)(void *));

uint32_t ditto_get_site_id (
    Ditto_t const * ditto);

void ditto_set_device_name (
    Ditto_t * ditto,
    char const * device_name);

/** \brief
 *  Describes how an attachment file should be handled by our Rust code.
 * 
 *  In most cases copying the file will be desirable but with the Android SDK,
 *  for example, we sometimes want to create a tempfile from an InputStream
 *  associated with the attachment file and then move that tempfile rather than
 *  copy it, so as to not make unnecessary copies.
 */
typedef enum AttachmentFileOperation {
    /** . */
    ATTACHMENT_FILE_OPERATION_COPY = 1,
    /** . */
    ATTACHMENT_FILE_OPERATION_MOVE,
} AttachmentFileOperation_t;

/** \brief
 *  [`Box`][`rust::Box`]`<[T]>` (fat pointer to a slice),
 *  but with a guaranteed `#[repr(C)]` layout.
 * 
 *  # C layout (for some given type T)
 * 
 *  ```c
 *  typedef struct {
 *      // Cannot be NULL
 *      T * ptr;
 *      size_t len;
 *  } slice_T;
 *  ```
 * 
 *  # Nullable pointer?
 * 
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct {

    /** \brief
     *  Pointer to the first element (if any).
     */
    uint8_t * ptr;

    /** \brief
     *  Element count
     */
    size_t len;

} slice_boxed_uint8_t;

typedef struct AttachmentHandle AttachmentHandle_t;

typedef struct {

    slice_boxed_uint8_t id;

    uint64_t len;

    AttachmentHandle_t * handle;

} Attachment_t;

/** \brief
 *  Creates new Attachment from a file and link it to the given Document.
 * 
 *  Returns following error codes:
 * 
 *  * `0` -- no error
 *  * `1` -- an error
 *  * `2` -- file not found
 *  * `3` -- permission denied
 * 
 *  In case of a non-zero return value, error message can be retrieved using
 *  `::ditto_error_message` function.
 */
uint32_t ditto_new_attachment_from_file (
    Ditto_t * ditto,
    char const * source_path,
    AttachmentFileOperation_t file_operation,
    Attachment_t * out_attachment);

char * ditto_get_complete_attachment_path (
    Ditto_t * ditto,
    AttachmentHandle_t const * handle);

void ditto_free_attachment_handle (
    AttachmentHandle_t * handle);

int32_t ditto_get_attachment_status (
    Ditto_t * ditto,
    slice_ref_uint8_t id,
    AttachmentHandle_t * * out_handle);

/** \brief
 *  Register a new callback to resolve the attachment.
 * 
 *  The callback status could be:
 *  * `0` -- complete, with a handle that can be used in ditto_get_complete_attachment_path
 *  * `1` -- progress, with additional info about bytes downloaded and total bytes to download
 *  * `2` -- deleted, as the attachment ceased to exist in the doc database
 * 
 *  Returns following error codes:
 * 
 *  * `0` -- no error
 *  * `1` -- an error
 *  * `2` -- invalid id
 *  * `3` -- attachment not found
 * 
 *  In case of a non-zero return value, error message can be retrieved using
 *  `::ditto_error_message` function.
 */
uint32_t ditto_resolve_attachment (
    Ditto_t * ditto,
    slice_ref_uint8_t id,
    void * ctx,
    void (*retain)(void *),
    void (*release)(void *),
    uint64_t * out_cancel_token,
    void (*on_complete_cb)(void *, AttachmentHandle_t *),
    void (*on_progress_cb)(void *, uint64_t, uint64_t),
    void (*on_deleted_cb)(void *));

/** \brief
 *  Cancels a resolve callback registered by ditto_resolve_attachment.
 * 
 *  Returns following error codes:
 * 
 *  * `0` -- no error
 *  * `1` -- an error
 *  * `2` -- invalid id
 *  * `3` -- token not found
 * 
 *  In case of a non-zero return value, error message can be retrieved using
 *  `::ditto_error_message` function.
 */
uint32_t ditto_cancel_resolve_attachment (
    Ditto_t * ditto,
    slice_ref_uint8_t id,
    uint64_t cancel_token);

/** \brief
 *  Returns a human-readable SDK version string.
 * 
 *  The returned string must be freed.
 */
char * ditto_get_sdk_version (void);

typedef enum Platform {
    /** . */
    PLATFORM_WINDOWS,
    /** . */
    PLATFORM_MAC,
    /** . */
    PLATFORM_IOS,
    /** . */
    PLATFORM_ANDROID,
    /** . */
    PLATFORM_LINUX,
    /** . */
    PLATFORM_UNKNOWN,
} Platform_t;

typedef enum Language {
    /** . */
    LANGUAGE_SWIFT,
    /** . */
    LANGUAGE_OBJECTIVE_C,
    /** . */
    LANGUAGE_C_PLUS_PLUS,
    /** . */
    LANGUAGE_C_SHARP,
    /** . */
    LANGUAGE_JAVASCRIPT,
    /** . */
    LANGUAGE_UNKNOWN,
} Language_t;

void ditto_init_sdk_version (
    Platform_t platform,
    Language_t language,
    char const * sdk_semver);

/** \brief
 *  The SDK requests to drop its handle to this WebSocket Client transport
 */
void websocket_client_free_handle (
    TransportHandle_WebsocketClientPlatformEvent_t * handle);

/** \brief
 *  The SDK requests to drop its handle to this TCP Client transport
 */
void static_tcp_client_free_handle (
    TransportHandle_StaticTcpClientPlatformEvent_t * handle);

/** \brief
 *  The platform advises Rust that a peer has been identified. We know only its
 *  announce string.
 */
void awdl_client_platform_peer_appeared (
    TransportHandle_AwdlClientPlatformEvent_t const * handle,
    char const * announce);

/** \brief
 *  The platform advises Rust that a peer has disappeared.
 */
void awdl_client_platform_peer_disappeared (
    TransportHandle_AwdlClientPlatformEvent_t const * handle,
    char const * announce);

/** \brief
 *  The platform advises Rust that searching status changed
 */
void awdl_client_scanning_state_changed (
    TransportHandle_AwdlClientPlatformEvent_t const * handle,
    OnlineState_t state,
    TransportCondition_t condition);

/** \brief
 *  The platform advises Rust that a given peer is now clear to queue up a new
 *  message whenever one is ready to go
 */
void awdl_client_ready_to_send (
    TransportHandle_AwdlClientPlatformEvent_t const * handle,
    char const * announce);

/** \brief
 *  Generic enum used by crate and platforms to indicate a connection status
 */
typedef enum ConnectState {
    /** . */
    CONNECT_STATE_DISCONNECTED,
    /** . */
    CONNECT_STATE_CONNECTED,
    /** . */
    CONNECT_STATE_CONNECTING,
    /** . */
    CONNECT_STATE_DISCONNECTING,
} ConnectState_t;

/** \brief
 *  The platform advises Rust that a peer has changed its current connection
 *  status
 */
void awdl_client_connect_state_changed (
    TransportHandle_AwdlClientPlatformEvent_t const * handle,
    char const * announce,
    ConnectState_t state);

/** \brief
 *  The platform advises Rust that a complete message has been received from a
 *  remote peer
 */
void awdl_client_data_available (
    TransportHandle_AwdlClientPlatformEvent_t const * handle,
    char const * announce);

/** \brief
 *  The SDK requests to drop its handle to the AWDL Client Transport
 * 
 *  At some point dropping this events channel will effectively shut down and remove the Transport.
 *  At time of writing, the Transport is still owned within Peer.
 */
void awdl_client_free_handle (
    TransportHandle_AwdlClientPlatformEvent_t * handle);

/** \brief
 *  Empty callback (useful for passing to `free` functions)
 */
void ditto_callback_nop (
    void const * _data);

/** \brief
 *  Empty error callback
 *  (useful for passing to `err_cb` functions to ignore errors; use with
 *  caution)
 */
void ditto_callback_err_nop (
    int32_t _code,
    char const * _err,
    void * _data);

/** \brief
 *  Releases `char *` value returned by DittoStore.
 * 
 *  DittoStore manages its own memory allocations and it is not safe to release
 *  such values with C's `free()`. That's why the structures it returns provide
 *  their own associated `free` function and this is one we need this function
 *  for `char *`.
 * 
 *  It should be used for values returned by functions like
 *  Ditto_QueryFilter::next.
 */
void ditto_c_string_free (
    char * s);

/** \brief
 *  Releases a byte array value returned by DittoStore.
 * 
 *  DittoStore manages its own memory allocations and it is not safe to release such values with
 *  C's `free()`. That's why the structures it returns provide their own associated `free`
 *  function.
 * 
 *  It should be used for values returned by functions like `ditto_document_cbor`.
 */
void ditto_c_bytes_free (
    slice_boxed_uint8_t bytes);

/** \brief
 *  The platform advises Rust that a peer has been identified. We know only its
 *  announce string.
 */
void awdl_server_platform_peer_appeared (
    TransportHandle_AwdlServerPlatformEvent_t const * handle,
    int64_t platform_id);

/** \brief
 *  The platform advises Rust that a peer has disappeared.
 */
void awdl_server_platform_peer_disappeared (
    TransportHandle_AwdlServerPlatformEvent_t const * handle,
    int64_t platform_id);

/** \brief
 *  The platform advises Rust that advertising status changed
 */
void awdl_server_advertising_state_changed (
    TransportHandle_AwdlServerPlatformEvent_t const * handle,
    OnlineState_t state,
    TransportCondition_t condition);

/** \brief
 *  The platform advises Rust that a given peer is now clear to queue up a new
 *  message whenever one is ready to go
 */
void awdl_server_ready_to_send (
    TransportHandle_AwdlServerPlatformEvent_t const * handle,
    int64_t platform_id);

/** \brief
 *  The platform advises Rust that a peer has changed its current connection
 *  status
 */
void awdl_server_connect_state_changed (
    TransportHandle_AwdlServerPlatformEvent_t const * handle,
    int64_t platform_id,
    ConnectState_t state);

/** \brief
 *  The platform advises Rust that a complete message has been received from a
 *  remote peer
 */
void awdl_server_data_available (
    TransportHandle_AwdlServerPlatformEvent_t const * handle,
    int64_t platform_id);

/** \brief
 *  The SDK requests to drop its handle to the AWDL Server Transport
 * 
 *  At some point dropping this events channel will effectively shut down and remove the Transport.
 *  At time of writing, the Transport is still owned within Peer.
 */
void awdl_server_free_handle (
    TransportHandle_AwdlServerPlatformEvent_t * handle);

typedef enum CLogLevel {
    /** . */
    C_LOG_LEVEL_ERROR = 1,
    /** . */
    C_LOG_LEVEL_WARNING,
    /** . */
    C_LOG_LEVEL_INFO,
    /** . */
    C_LOG_LEVEL_DEBUG,
    /** . */
    C_LOG_LEVEL_VERBOSE,
} CLogLevel_t;

/** \brief
 *  Registers a custom logging callback to be called whenever Ditto wants to
 *  issue a log (on _top_ of emitting the log to the console).
 * 
 *  Care should be taken not to perform any Ditto operations within this
 *  callback, since those could emit new ditto logs, leading to a recursive
 *  situation. More specifically, this should not be fed `ditto_log`.
 * 
 *  A `NULL` may be fed to provide no callback (thus unregistering any
 *  previously registered one).
 */
void ditto_logger_set_custom_log_cb (
    void (*custom_log_cb)(CLogLevel_t, char const *));

/** \brief
 *  Registers a file path where logs will be written to, whenever Ditto wants
 *  to issue a log (on _top_ of emitting the log to the console).
 * 
 *  The path, if any, must be within an already existing directory.
 * 
 *  A `NULL` may be fed to provide no file (thus unregistering any previously
 *  registered one).
 * 
 *  Returns `0` on success, and `-1` otherwise (and the thread local error
 *  message is set accordingly).
 */
int8_t ditto_logger_set_log_file (
    char const * log_file);

/** \brief
 *  Initializes and registers the global Ditto logger.
 */
void ditto_logger_init (void);

void ditto_logger_enabled (
    bool enabled);

bool ditto_logger_enabled_get (void);

void ditto_logger_emoji_headings_enabled (
    bool enabled);

bool ditto_logger_emoji_headings_enabled_get (void);

void ditto_logger_minimum_log_level (
    CLogLevel_t log_level);

CLogLevel_t ditto_logger_minimum_log_level_get (void);

/** \brief
 *  Log function called over FFI such that logging can be grouped into a single
 *  logging mechanism.
 */
void ditto_log (
    CLogLevel_t level,
    char const * msg);

typedef struct CCompiledQuery CCompiledQuery_t;

/** \brief
 *  Query compilation result
 */
typedef enum QueryCompileResult {
    /** \brief
     *  Compilation was successful.
     */
    QUERY_COMPILE_RESULT_SUCCESS = 0,
    /** \brief
     *  Invalid input. Can be wrong syntax, wrong result type, etc.
     */
    QUERY_COMPILE_RESULT_INVALID_INPUT = 1,
    /** \brief
     *  Failure during compilation or transpilation.
     */
    QUERY_COMPILE_RESULT_COMPILE_FAILED = 2,
} QueryCompileResult_t;

/** \brief
 *  Compiles string query into JMESPath query
 * 
 *  Return codes:
 * 
 *  * `QUERY_COMPILE_RESULT_SUCCESS` -- success
 *  * `QUERY_COMPILE_RESULT_COMPILE_FAILED` -- invalid expression
 */
QueryCompileResult_t ditto_query_compile (
    char const * expr,
    CCompiledQuery_t * * query);

/** \brief
 *  Compiles JMESPath query
 * 
 *  Return codes:
 * 
 *  * `QUERY_COMPILE_RESULT_SUCCESS` -- success
 *  * `QUERY_COMPILE_RESULT_COMPILE_FAILED` -- invalid expression
 */
QueryCompileResult_t ditto_query_jmespath_compile (
    char const * expr,
    CCompiledQuery_t * * query);

/** \brief
 *  Releases memory held by a compiled query
 */
void ditto_query_free (
    CCompiledQuery_t * query);

/** \brief
 *  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout
 */
typedef struct {

    char * * ptr;

    size_t len;

    size_t cap;

} Vec_char_ptr_t;

Vec_char_ptr_t * new_c_string_vec (void);

void free_c_string_vec (
    Vec_char_ptr_t * strings);

typedef struct CDocument CDocument_t;

/** \brief
 *  Creates a new document from CBOR
 * 
 *  It will allocate a new document and set `document` pointer to it. It will
 *  later need to be released with `::ditto_document_free`.
 * 
 *  The input `cbor` must be a valid CBOR.
 * 
 *  Return codes:
 * 
 *  * `0` -- success
 *  * `1` -- invalid CBOR
 *  * `2` -- cbor is not an object
 *  * `3` -- ID string is empty
 */
int32_t ditto_document_new_cbor (
    slice_ref_uint8_t cbor,
    char const * id,
    uint32_t _site_id,
    CDocument_t * * document);

/** \brief
 *  Creates a new document from CBOR and a provided timestamp
 * 
 *  It will allocate a new document and set `document` pointer to it. It will
 *  later need to be released with `::ditto_document_free`.
 * 
 *  The input `cbor` must be a valid CBOR.
 * 
 *  Return codes:
 * 
 *  * `0` -- success
 *  * `1` -- invalid CBOR
 *  * `2` -- cbor is not an object
 *  * `3` -- ID string is empty
 */
int32_t ditto_document_new_cbor_with_timestamp (
    slice_ref_uint8_t cbor,
    char const * id,
    uint32_t _site_id,
    uint32_t timestamp,
    CDocument_t * * document);

/** \brief
 *  Document's rendered ID
 * 
 *  The resulting string has to be released with `::ditto_c_string_free`
 */
char * ditto_document_id (
    CDocument_t const * document);

/** \brief
 *  Document's rendered JSON
 * 
 *  The resulting string has to be released with `::ditto_c_string_free`
 */
char * ditto_document_json (
    CDocument_t const * document);

/** \brief
 *  Document's CBOR
 */
slice_boxed_uint8_t ditto_document_cbor (
    CDocument_t const * document);

int32_t ditto_document_replace_with_counter (
    CDocument_t * document,
    char const * pointer);

int32_t ditto_document_replace_with_counter_with_timestamp (
    CDocument_t * document,
    char const * pointer,
    uint32_t timestamp);

int32_t ditto_document_increment_counter (
    CDocument_t * document,
    char const * pointer,
    double amount);

int32_t ditto_document_set_cbor (
    CDocument_t * document,
    char const * pointer,
    slice_ref_uint8_t cbor,
    bool create_path);

int32_t ditto_document_set_cbor_with_timestamp (
    CDocument_t * document,
    char const * pointer,
    slice_ref_uint8_t cbor,
    bool create_path,
    uint32_t timestamp);

/** \brief
 *  Removes a value from a document. The behavior depends on the `Repr` of the
 *  element at the JMESPath path pointed to by `pointer`.
 * 
 *  ```text
 *  // ________________________________________________________________________________________
 *  // |`pointer`   | Foo `Repr` | Action                                                     |
 *  // |------------|------------|------------------------------------------------------------|
 *  // | "foo.bar"  | Object     | Deletes bar property                                       |
 *  // | "foo[1]"   | Array      | Removes at index and shifts all subsequent indexes right   |
 *  // ----------------------------------------------------------------------------------------
 *  ```
 * 
 *  # Arguments
 * 
 *  * `document` - A pointer to the document which was previously passed across the FFI
 *     layer by `ditto_document_new_*` or returned from a query.
 *  * `pointer` - A JMESPath _pointer_ to a `Repr` within `document` which is to be removed.
 * 
 *  # Returns
 * 
 *  `0` if the remove was successful or non-zero to indicate failure. To retrieve an error
 *  message in the case of failure, call `ditto_error_message()`.
 */
int32_t ditto_document_remove (
    CDocument_t * document,
    char const * pointer);

/** \brief
 *  Inserts a value into a document. The behavior depends on the `Repr` of the
 *  element at the JMESPath path pointed to by `pointer`.
 * 
 *  ```text
 *  // ________________________________________________________________________________________
 *  // |`pointer`   | Foo `Repr` | Action                                                     |
 *  // |------------|------------|------------------------------------------------------------|
 *  // | "foo.bar"  | Object     | Sets the bar property to the supplied CBOR item            |
 *  // | "foo[1]"   | Array      | Inserts the supplied CBOR item at the index specified      |
 *  // ----------------------------------------------------------------------------------------
 *  ```
 * 
 *  # Arguments
 * 
 *  * `document` - A pointer to the document which was previously passed across the FFI
 *     layer by `ditto_document_new_*` or returned from a query.
 *  * `pointer` - A JMESPath _pointer_ to a `Repr` within `document` which is to be removed.
 * 
 *  # Returns
 * 
 *  `0` if the remove was successful or non-zero to indicate failure. To retrieve an error
 *  message in the case of failure, call `ditto_error_message()`.
 */
int32_t ditto_document_insert_cbor (
    CDocument_t * document,
    char const * pointer,
    slice_ref_uint8_t cbor);

int32_t ditto_document_push_cbor (
    CDocument_t * document,
    char const * pointer,
    slice_ref_uint8_t cbor);

int32_t ditto_document_pop_cbor (
    CDocument_t * document,
    char const * pointer,
    slice_boxed_uint8_t * out_cbor);

/** \brief
 *  Updates the document with values taken from provided CBOR data.
 * 
 *  Returns following error codes:
 * 
 *  * `0` -- no error
 *  * `1` -- invalid CBOR data
 *  * `2` -- CBOR data was not a map
 *  * `3` -- update error
 * 
 *  In case of a non-zero return value, error message can be retrieved using
 *  `::ditto_error_message` function.
 */
int32_t ditto_document_update (
    CDocument_t * document,
    slice_ref_uint8_t cbor,
    bool create_path);

/** \brief
 *  Gets the CBOR value at the pointer.
 * 
 *  The `.ptr` field is `NULL` if none found (in which case the length contains garbage).
 * 
 *  The resulting bytes have to be released with `::ditto_c_bytes_free`
 */
slice_boxed_uint8_t ditto_document_get_cbor (
    CDocument_t const * document,
    char const * pointer);

/** \brief
 *  Releases the document
 */
void ditto_document_free (
    CDocument_t * document);

/** \brief
 *  The platform advises Rust that a peer has been identified.
 */
void mdns_platform_peer_appeared (
    TransportHandle_MdnsClientPlatformEvent_t const * handle,
    char const * announce_string);

/** \brief
 *  The platform advises Rust that a peer's service has disappeared from mDNS.
 */
void mdns_platform_peer_disappeared (
    TransportHandle_MdnsClientPlatformEvent_t const * handle,
    char const * announce_string);

/** \brief
 *  The platform advises Rust that the status of searching for services has changed.
 */
void mdns_scanning_state_changed (
    TransportHandle_MdnsClientPlatformEvent_t const * handle,
    OnlineState_t state,
    TransportCondition_t condition);

/** \brief
 *  The platform advises Rust that we have resolved a peer's hostname and port
 */
void mdns_service_did_resolve (
    TransportHandle_MdnsClientPlatformEvent_t const * handle,
    char const * announce_string,
    char const * hostname,
    uint16_t port);

/** \brief
 *  The platform advises Rust that we failed to resolve a peer's hostname and port
 */
void mdns_service_did_not_resolve (
    TransportHandle_MdnsClientPlatformEvent_t const * handle,
    char const * announce_string);

/** \brief
 *  The SDK requests to drop its handle to the mDNS discovery transport
 * 
 *  At some point dropping this events channel will effectively shut down and remove the Transport.
 *  At time of writing, the Transport is still owned within Peer.
 */
void mdns_client_free_handle (
    TransportHandle_MdnsClientPlatformEvent_t * handle);

/** \brief
 *  Retrieves last thread-local error message (used by some synchronous APIs)
 *  and removes it. Subsequent call to this function (if nothing else has
 *  happened) will always return `NULL`.
 * 
 *  Returns `NULL` if there was no error. A non-null result MUST be freed using
 *  `ditto_c_string_free`.
 */
char * ditto_error_message (void);

/** \brief
 *  Retrieves last thread-local error message (used by some synchronous APIs)
 *  and retains ownership of it.
 * 
 *  Returns `NULL` if there was no error. A non-null result MUST be freed using
 *  `ditto_c_string_free`.
 */
char * ditto_error_message_peek (void);

/** \brief
 *  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout
 */
typedef struct {

    CDocument_t * * ptr;

    size_t len;

    size_t cap;

} Vec_CDocument_ptr_t;

void ditto_vec_documents_free (
    Vec_CDocument_ptr_t docs);

/** \brief
 *  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout
 */
typedef struct {

    size_t * ptr;

    size_t len;

    size_t cap;

} Vec_size_t;

void ditto_vec_usizes_free (
    Vec_size_t usizes);

/** \brief
 *  Frees a `Vec_CDocument_ptr_t`, used in `c_cb_params`.
 * 
 *  \remark This functions frees both the backing buffer allocation and each
 *  individual `Document` pointer. If ownership has been taken of the latter,
 *  then you must ensure the `len` field of the struct is zeroed before calling
 *  this function.
 */
void ditto_free_documents (
    Vec_CDocument_ptr_t documents);

/** \brief
 *  [`Box`][`rust::Box`]`<[T]>` (fat pointer to a slice),
 *  but with a guaranteed `#[repr(C)]` layout.
 * 
 *  # C layout (for some given type T)
 * 
 *  ```c
 *  typedef struct {
 *      // Cannot be NULL
 *      T * ptr;
 *      size_t len;
 *  } slice_T;
 *  ```
 * 
 *  # Nullable pointer?
 * 
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct {

    /** \brief
     *  Pointer to the first element (if any).
     */
    size_t * ptr;

    /** \brief
     *  Element count
     */
    size_t len;

} slice_boxed_size_t;

/** \brief
 *  Frees a `slice_box_size_t`, used in `c_cb_params`.
 */
void ditto_free_indices (
    slice_boxed_size_t indices);

typedef enum QuerySortDirection {
    /** . */
    QUERY_SORT_DIRECTION_ASCENDING = 1,
    /** . */
    QUERY_SORT_DIRECTION_DESCENDING,
} QuerySortDirection_t;

/** \brief
 *  Order Definition.
 */
typedef struct {

    /** \brief
     *  \private *
     */
    CCompiledQuery_t * projection;

    /** \brief
     *  \private *
     */
    QuerySortDirection_t direction;

} COrderDefinition_t;

/** \brief
 *  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.
 * 
 *  # C layout (for some given type T)
 * 
 *  ```c
 *  typedef struct {
 *      // Cannot be NULL
 *      T * ptr;
 *      size_t len;
 *  } slice_T;
 *  ```
 * 
 *  # Nullable pointer?
 * 
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct {

    /** \brief
     *  Pointer to the first element (if any).
     */
    COrderDefinition_t const * ptr;

    /** \brief
     *  Element count
     */
    size_t len;

} slice_ref_COrderDefinition_t;

/** \brief
 *  Describes how a live query callback's availability should be treated.
 * 
 *  If `Always` is specified then as soon as a transaction is committed that
 *  impacts the live query the consumer-provided callback will be called with
 *  the relevant update information. This can be temporarily delayed if there's
 *  a lot of activity leading to the event receivers lagging or if groups of
 *  transactions are coalesced into a single live query update.
 * 
 *  If `WhenSignalled` is specified then the consumer-provided live query
 *  callback will only be called when there is a transaction committed that
 *  impacts the live query *and* the consumer has signalled that they are ready
 *  to receive a new live query event (via the callback).
 */
typedef enum LiveQueryAvailability {
    /** . */
    LIVE_QUERY_AVAILABILITY_ALWAYS,
    /** . */
    LIVE_QUERY_AVAILABILITY_WHEN_SIGNALLED,
} LiveQueryAvailability_t;

typedef struct {

    /** \brief
     *  Must be freed with `ditto_free_documents`.
     */
    Vec_CDocument_ptr_t documents;

    bool is_initial;

    /** \brief
     *  Must be freed with `ditto_free_documents`.
     */
    Vec_CDocument_ptr_t old_documents;

    /** \brief
     *  Must be freed using `ditto_free_indices`.
     */
    slice_boxed_size_t insertions;

    /** \brief
     *  Must be freed using `ditto_free_indices`.
     */
    slice_boxed_size_t deletions;

    /** \brief
     *  Must be freed using `ditto_free_indices`.
     */
    slice_boxed_size_t updates;

    /** \brief
     *  Must be freed using `ditto_free_indices`.
     */
    slice_boxed_size_t moves;

} c_cb_params_t;

int32_t ditto_live_query_register (
    Ditto_t const * ditto,
    char const * coll_name,
    CCompiledQuery_t const * query,
    slice_ref_COrderDefinition_t order_by,
    int32_t limit,
    uint32_t offset,
    LiveQueryAvailability_t lq_availability,
    int64_t * id,
    void * ctx,
    void (*retain)(void *),
    void (*release)(void *),
    void (*c_cb)(void *, c_cb_params_t));

int32_t ditto_live_query_start (
    Ditto_t const * ditto,
    int64_t id);

/** \brief
 *  OrderBy Parameter
 */
typedef struct {

    char const * query_c_str;

    QuerySortDirection_t direction;

} COrderByParam_t;

/** \brief
 *  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.
 * 
 *  # C layout (for some given type T)
 * 
 *  ```c
 *  typedef struct {
 *      // Cannot be NULL
 *      T * ptr;
 *      size_t len;
 *  } slice_T;
 *  ```
 * 
 *  # Nullable pointer?
 * 
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct {

    /** \brief
     *  Pointer to the first element (if any).
     */
    COrderByParam_t const * ptr;

    /** \brief
     *  Element count
     */
    size_t len;

} slice_ref_COrderByParam_t;

/** \brief
 *  Convenience function for `ditto_live_query_register`, so as not to require
 *  pre-compiling the query.
 */
int32_t ditto_live_query_register_str (
    Ditto_t const * ditto,
    char const * coll_name,
    char const * query,
    slice_ref_COrderByParam_t order_by,
    int32_t limit,
    uint32_t offset,
    LiveQueryAvailability_t lq_availability,
    int64_t * id,
    void * ctx,
    void (*retain)(void *),
    void (*release)(void *),
    void (*c_cb)(void *, c_cb_params_t));

void ditto_stop_all_live_queries (
    Ditto_t * ditto);

void ditto_live_query_stop (
    Ditto_t const * ditto,
    int64_t id);

void ditto_live_query_signal_available_next (
    Ditto_t const * ditto,
    int64_t id);

void ble_advertisement_heard (
    TransportHandle_BleClientPlatformEvent_t const * handle,
    uint8_16_array_t const * peripheral_uuid,
    slice_ref_uint8_t local_name,
    float rssi);

void ble_scanning_state_changed (
    TransportHandle_BleClientPlatformEvent_t const * handle,
    OnlineState_t state,
    TransportCondition_t result);

void ble_peripheral_mtu_updated (
    TransportHandle_BleClientPlatformEvent_t const * handle,
    uint8_16_array_t const * uuid,
    uint32_t mtu);

void ble_connection_state_changed (
    TransportHandle_BleClientPlatformEvent_t const * handle,
    uint8_16_array_t const * peripheral_uuid,
    ConnectState_t state);

void ble_received_from_peripheral (
    TransportHandle_BleClientPlatformEvent_t const * handle,
    uint8_16_array_t const * peripheral_uuid,
    BleDataType_t data_type,
    slice_ref_uint8_t data);

void ble_peripheral_ready_to_send (
    TransportHandle_BleClientPlatformEvent_t const * handle,
    uint8_16_array_t const * uuid);

/** \brief
 *  The SDK requests to drop its handle to the BLE Client Transport
 * 
 *  At some point dropping this events channel will effectively shut down and remove the Transport.
 *  At time of writing, the Transport is still owned within Peer.
 */
void ble_client_free_handle (
    TransportHandle_BleClientPlatformEvent_t * handle);

int32_t ditto_get_collection_names (
    Ditto_t const * ditto,
    Vec_char_ptr_t * out_names);

/** \brief
 *  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.
 * 
 *  # C layout (for some given type T)
 * 
 *  ```c
 *  typedef struct {
 *      // Cannot be NULL
 *      T * ptr;
 *      size_t len;
 *  } slice_T;
 *  ```
 * 
 *  # Nullable pointer?
 * 
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct {

    /** \brief
     *  Pointer to the first element (if any).
     */
    char const * const * ptr;

    /** \brief
     *  Element count
     */
    size_t len;

} slice_ref_char_const_ptr_t;

/** \brief
 *  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.
 * 
 *  # C layout (for some given type T)
 * 
 *  ```c
 *  typedef struct {
 *      // Cannot be NULL
 *      T * ptr;
 *      size_t len;
 *  } slice_T;
 *  ```
 * 
 *  # Nullable pointer?
 * 
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct {

    /** \brief
     *  Pointer to the first element (if any).
     */
    CCompiledQuery_t const * const * ptr;

    /** \brief
     *  Element count
     */
    size_t len;

} slice_ref_CCompiledQuery_const_ptr_t;

int32_t ditto_queries_hash (
    Ditto_t const * ditto,
    slice_ref_char_const_ptr_t coll_names,
    slice_ref_CCompiledQuery_const_ptr_t queries,
    uint64_t * c_hash);

int32_t ditto_queries_hash_mnemonic (
    Ditto_t const * ditto,
    slice_ref_char_const_ptr_t coll_names,
    slice_ref_CCompiledQuery_const_ptr_t queries,
    char * * out_mnemonic_hash);

int32_t ditto_collection (
    Ditto_t const * ditto,
    char const * name);

typedef struct CWriteTransaction CWriteTransaction_t;

int32_t ditto_collection_insert (
    Ditto_t const * ditto,
    char const * coll_name,
    CWriteTransaction_t * transaction,
    CDocument_t * document,
    char * * id);

int32_t ditto_collection_update (
    Ditto_t const * ditto,
    char const * coll_name,
    CWriteTransaction_t * transaction,
    CDocument_t * document);

/** \brief
 *  Update multiple documents in a collection, using the provided write
 *  transaction.
 * 
 *  # Return Values
 * 
 *  - Returns `0` if all links were successfully updated in all documents.
 *  - Returns `-1` if one or more documents' links fail to all update
 *  successfully, but all documents themselves are successfully updated. Note
 *  that in the event of an attachment failing to update, updates are still
 *  attempted on the rest of the attachments and the rest of the documents.
 *  - If a document fails to update, the appropriate error code is returned for
 *  the cause of the failure. Note that if a document fails to update, no more
 *  document updates are attempted.
 */
int32_t ditto_collection_update_multiple (
    Ditto_t const * ditto,
    char const * coll_name,
    CWriteTransaction_t * transaction,
    Vec_CDocument_ptr_t documents);

/** \brief
 *  Evict a document from the collection, using the provided write transaction.
 * 
 *  `was_evicted` is set to indicate whether the document was removed
 *  successfully.
 */
int32_t ditto_collection_evict (
    Ditto_t const * ditto,
    char const * coll_name,
    CWriteTransaction_t * transaction,
    char const * id,
    bool * out_evicted);

/** \brief
 *  Evict all documents returned by the specified query from a collection.
 * 
 *  `out_ids` is set to the list of IDs of all documents successfully evicted.
 */
int32_t ditto_collection_evict_query_str (
    Ditto_t const * ditto,
    char const * coll_name,
    CWriteTransaction_t * transaction,
    char const * query,
    slice_ref_COrderByParam_t order_by_params,
    int32_t limit,
    uint32_t offset,
    Vec_char_ptr_t * out_ids);

void ditto_vec_char_ptr_free (
    Vec_char_ptr_t char_p);

/** \brief
 *  Remove a document from the collection, using the provided write transaction.
 * 
 *  `out_removed` is set to indicate whether the document was removed
 *  successfully.
 */
int32_t ditto_collection_remove (
    Ditto_t const * ditto,
    char const * coll_name,
    CWriteTransaction_t * transaction,
    char const * id,
    bool * out_removed);

/** \brief
 *  Remove all documents returned by the specified query from a collection.
 * 
 *  `out_ids` is set to the list of IDs of all documents successfully removed.
 */
int32_t ditto_collection_remove_query_str (
    Ditto_t const * ditto,
    char const * coll_name,
    CWriteTransaction_t * transaction,
    char const * query,
    slice_ref_COrderByParam_t order_by_params,
    int32_t limit,
    uint32_t offset,
    Vec_char_ptr_t * out_ids);

typedef struct CReadTransaction CReadTransaction_t;

int32_t ditto_collection_get (
    Ditto_t const * ditto,
    char const * coll_name,
    char const * id,
    CReadTransaction_t * transaction,
    CDocument_t * * document);

typedef struct CQueryFilter CQueryFilter_t;

void ditto_query_filter_free (
    CQueryFilter_t * query_filter);

int32_t ditto_query_filter_next (
    Ditto_t const * ditto,
    CQueryFilter_t * query_filter,
    CDocument_t * * document);

int32_t ditto_read_transaction (
    Ditto_t const * ditto,
    CReadTransaction_t * * txn);

int32_t ditto_read_transaction_query (
    Ditto_t const * ditto,
    char const * coll_name,
    CReadTransaction_t * transaction,
    CCompiledQuery_t const * query,
    slice_ref_COrderDefinition_t order_by,
    int32_t limit,
    uint32_t offset,
    CQueryFilter_t * * query_filter);

/** \brief
 *  Execute the specified query on a collection.
 * 
 *  `out_documents` is set to the list of all documents successfully retrieved from the collection.
 */
int32_t ditto_collection_exec_query_str (
    Ditto_t const * ditto,
    char const * coll_name,
    CWriteTransaction_t * transaction,
    char const * query,
    slice_ref_COrderByParam_t order_by_params,
    int32_t limit,
    uint32_t offset,
    Vec_CDocument_ptr_t * out_documents);

void ditto_read_transaction_free (
    CReadTransaction_t * transaction);

int32_t ditto_write_transaction (
    Ditto_t const * ditto,
    CWriteTransaction_t * * txn);

int32_t ditto_write_transaction_commit (
    Ditto_t const * ditto,
    CWriteTransaction_t * transaction);

int32_t ditto_write_transaction_query (
    Ditto_t const * ditto,
    char const * coll_name,
    CWriteTransaction_t * transaction,
    CCompiledQuery_t const * query,
    slice_ref_COrderDefinition_t order_by,
    int32_t limit,
    uint32_t offset,
    CQueryFilter_t * * query_filter);

void ditto_write_transaction_free (
    CWriteTransaction_t * transaction);

void ditto_write_transaction_rollback (
    CWriteTransaction_t * transaction);

void ble_advertising_state_changed (
    TransportHandle_BleServerPlatformEvent_t const * handle,
    OnlineState_t state,
    TransportCondition_t result);

void ble_central_mtu_updated (
    TransportHandle_BleServerPlatformEvent_t const * handle,
    uint8_16_array_t const * uuid,
    uint32_t mtu);

void ble_received_from_central (
    TransportHandle_BleServerPlatformEvent_t const * handle,
    uint8_16_array_t const * central_uuid,
    BleDataType_t data_type,
    slice_ref_uint8_t data);

void ble_central_unsubscribed (
    TransportHandle_BleServerPlatformEvent_t const * handle,
    uint8_16_array_t const * central_uuid);

void ble_central_ready_to_send (
    TransportHandle_BleServerPlatformEvent_t const * handle,
    uint8_16_array_t const * uuid);

/** \brief
 *  The SDK requests to drop its handle to the BLE Server Transport
 * 
 *  At some point dropping this events channel will effectively shut down and remove the Transport.
 *  At time of writing, the Transport is still owned within Peer.
 */
void ble_server_free_handle (
    TransportHandle_BleServerPlatformEvent_t * handle);

/** \brief
 *  The platform advises Rust that the status of publishing our service has
 *  changed.
 */
void mdns_advertising_state_changed (
    TransportHandle_MdnsServerPlatformEvent_t const * handle,
    OnlineState_t state,
    TransportCondition_t condition);

/** \brief
 *  The SDK requests to drop its handle to the mDNS advertising service.
 * 
 *  Ideally this should remove the advertiser automatically.
 *  At time of writing now this must be done manually through Peer.
 */
void mdns_server_free_handle (
    TransportHandle_MdnsServerPlatformEvent_t * handle);


#ifdef __cplusplus
} /* extern \"C\" */
#endif

#endif /* __RUST_DITTOFFI__ */
